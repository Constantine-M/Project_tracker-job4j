package ru.job4j.poly;

/**
 * Данный класс используем наше хранилище.
 * Здесь мы наглядно проверяем работу механизма "полиморфизм".
 * Сначала мы в качестве аргумента (используемых объектов) используем
 * объекты класса DbStore.
 * Потом создаем наследника класса DbStore с названием FileStore
 * и используем его (ниже объясню).
 */
public class Service {
    /**
     * Здесь вместо создания поля, которое описывает объект класса DbStore,
     * использовали поле, которое относится к интерфейсу.
     */
    private Store store;

    /**
     * Ранее аргументом данного конструктора был объект класса DbStore.
     * Теперь мы используем интерфейс.
     * @param store
     */
    public Service(Store store) {
        this.store = store;
    }

    public void extract() {
        store.save("Petr Arsentev");
    }

    /**
     * Здесь после создания класса-наследника FileStore,
     * мы можем заменить строку DbStore store = new DbStore(); на
     * DbStore store = new FileStore();.
     * Это есть приведение типов.
     * Проблема: для программиста, который будет читать этот код будет не понятно,
     * почему мы записываем данные в файл, если у нас в коде прописана база.
     * После этого мы создали интерфейс и тем самым отвязали 2 хранилища друг от друга.
     * Теперь нам нужно отвязать сервис. Внесли корректировки в поле и конструктор.
     * Теперь все классы не связаны между собой.
     * Это позволяет заменить одну часть программы на другую без переписывания кода.
     */
    public static void main(String[] args) {
        Store store = new DbStore();
        /* Store otherStore = new FileStore();*/
        Service service = new Service(store);
        service.extract();
    }
}
