package ru.job4j.stream.card;

import java.util.stream.Stream;

/**
 * Чтобы этот класс стал публичным,
 * необходимо его выделять в
 * отдельный класс.
 */
enum Suit {
    Diamonds, Hearts, Spades, Clubs
}

/**
 * Чтобы этот класс стал публичным,
 * необходимо его выделять в
 * отдельный класс.
 */
enum Value {
    V_6, V_7, V_8
}

/**
 * 8. Перенос методов в Stream API.
 */
public class Card {
    private Suit suit;
    private Value value;

    public Card(Suit suit, Value value) {
        this.suit = suit;
        this.value = value;
    }

    /**
     * Сейчас объясню.
     * 1.Метод {@code Stream.of} принимает массив
     * объектов и создает на их основе стрим.
     * Т.о. мы помещаем в стрим объекты класса Suit.
     * 2.Метод {@code flatMap} возвращает поток.
     * На вход flatMap() поступает функция, задача
     * которой получить из объекта стрим и
     * конкатенировать его с другими. Таким образом,
     * мы создаем стримы из массивов строк и
     * соединяем их вместе.
     * В нашем случае мы передаем функцию,
     * которая получает стрим из объектов класса
     * Value. А потом конкатенриуем этот стрим с
     * первым стримом, тем самым как бы сглаживая
     * поток. Вместо 2х уровнего потока, мы получаем
     * одноуровневый.
     * 3.Далее с единственным (сглаженным) потоком
     * мы производим преобразование с помощью
     * метода {@code map()}, а именно сопоставить
     * элементы 2х классов (перетасовать карты в колоде).
     * 4.Выводим получившееся на консоль.
     */
    public static void main(String[] args) {
        Stream.of(Suit.values())
                .flatMap(s -> Stream.of(Value.values())
                        .map(val -> s + " " + val))
                .forEach(System.out::println);
    }
}
