package ru.job4j.course.stream.card;

import java.util.stream.Stream;

/**
 * Чтобы этот класс стал публичным,
 * необходимо его выделять в
 * отдельный класс.
 */
enum Suit {
    Diamonds, Hearts, Spades, Clubs
}

/**
 * Чтобы этот класс стал публичным,
 * необходимо его выделять в
 * отдельный класс.
 */
enum Value {
    V_6, V_7, V_8
}

/**
 * 8. Перенос методов в Stream API.
 */
public class Card {
    private Suit suit;
    private Value value;

    /**
     * Данный конструктор здесь не просто так.
     * Помни, что нам нужно создать
     * карточную колоду. 2 стрима мы
     * объединяли как раз для этого.
     */
    public Card(Suit suit, Value value) {
        this.suit = suit;
        this.value = value;
    }

    @Override
    public String toString() {
        return "Card{"
                + "suit=" + suit
                + ", value=" + value
                + '}';
    }

    /**
     * Сейчас объясню.
     * 1.Метод {@code Stream.of} принимает массив
     * объектов и создает на их основе стрим.
     * Т.о. мы помещаем в стрим объекты класса Suit.
     * 2.Метод {@code flatMap} возвращает поток.
     * На вход flatMap() поступает функция, задача
     * которой получить из объекта стрим и
     * конкатенировать его с другими. Таким образом,
     * мы создаем стримы из массивов строк и
     * соединяем их вместе.
     * В нашем случае мы передаем функцию,
     * которая получает стрим из объектов класса
     * Value. А потом конкатенриуем этот стрим с
     * первым стримом, тем самым как бы сглаживая
     * поток. Вместо 2х уровнего потока, мы получаем
     * одноуровневый.
     * 3.Далее с единственным (сглаженным) потоком
     * мы производим преобразование с помощью
     * метода {@code map()}, а именно создаем
     * колоду карт (ведь ее у нас не было).
     * У нас был только констуктор этой колоды.
     * Нужно было колоду сгенерировать.
     * 4.Выводим получившееся на консоль.
     */
    public static void main(String[] args) {
        Stream.of(Suit.values())
                .flatMap(s -> Stream.of(Value.values())
                        .map(v -> new Card(s, v)))
                .forEach(System.out::println);
    }
}
